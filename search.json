[{"title":"Java 8 新特性","url":"/2023/04/27/Java8Characters/","content":"Lambda表达式Lambda运行将函数作为一个方法的参数，也就是函数作为参数传递到方法中。使用lambda表达式可以让代码更加简洁。\nLambda表达式的使用场景：用以简化接口实现。\n函数式接口：一个接口中只有一个实现类必须实现的抽象方法\n//lambda表达式基本语法(参数列表) -&gt; &#123;    //方法体&#125;\n\nStream APIStream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。\n对流的操作分为两种\n\n中间操作，每次返回一个新的流，可以有多个\n终端操作，对流进行终端操作后流无法再次使用，会产生新的集合或值\n\n特性\n\nStream不存储数据，而是按照特定规则对数据进行计算\nStream不改变数据源，通常会产生一个新的集合或值\nStream具有延迟执行特性，只有调用终端操作时，中间操作才会执行\n\nStream的创建// Collection.stream()  获取集合的StreamList&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Stream&lt;String&gt; stream = list.stream();// 创建一个顺序流Stream&lt;String&gt; parallelStream = list.parallelStream();// 创建一个并行流//Arrays.stream(T[] array)  获取数组的Streamint[] array=&#123;1,3,5,6,8&#125;;IntStream stream = Arrays.stream(array);//Stream.of()\tStream的静态方法，获取数组的StreamStream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);//Stream.iterate() 遍历获取Stream&lt;Integer&gt; stream2 = Stream.iterate(0, (x) -&gt; x + 3).limit(4);//多次执行方法的返回值生成的数组的StreamStream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(3);\n\nStream的使用Stream的元素是以Optional类型存在的，Optional类是一个可以为null的容器对象，如果值存在则isPresent()为true，get()返回该容器中的对象。\n","categories":["Java语言"]},{"title":"集合的使用","url":"/2023/04/27/Collection/","content":"一、集合概述为了方便对多个对象进行存储和操作，集合是一种Java容器，可以动态地把多个对象引用放入容器中\n数组存储的特点\n一旦初始化后，长度不可改变，元素类型不可改变\n提供的方法很少，对于添加、删除、获取实际元素个数等操作非常不便\n有序、可重复\n\n集合的两种体系\nCollection接口：单列数据，定义了存取一组对象的方法的集合。\nList：有序、可重复的集合\nSet：无序、不可重复的集合\n\n\nMap接口：双列数据，保存具有映射关系的“key-value”键值对集合\n\n\n\n二、Collection接口常用方法public class CollectionTest &#123;\t@Test\tpublic void test1()&#123;\t\tCollection col1 = new ArrayList();\t\t// add(Object o)\t添加元素\t\tcol1.add(&quot;wanfeng&quot;);\t\tcol1.add(&quot;jingyu&quot;);\t\tcol1.add(123);\t\t// size()\t元素个数\t\tSystem.out.println(&quot;col size = &quot;+col1.size());\t\t// addAll(Collection c)\t添加集合中的所有元素\t\tCollection col2 = new ArrayList();\t\tcol2.add(false);\t\tcol2.add(34.56);\t\tcol2.add(29);\t\tcol2.add(&quot;wanwan&quot;);\t\tStudent s1 = new Student(&quot;wanfeng&quot;, 12);\t\tcol2.add(s1);\t\tcol1.addAll(col2);\t\tSystem.out.println(col1);\t\t// isEmpty()\t判断集合是否有元素\t\tSystem.out.println(col1.isEmpty());\t\t// clear()\t清空所有元素\t\tcol1.clear();\t\tSystem.out.println(col1);\t\t// contains()\t元素是否存在，ArrayList源码中调用的是Object类的equals方法（==比较地址值），\t\t// 若要比较内容需要在类中重写equals方法\t\tSystem.out.println(col2.contains(34.56));\t\tSystem.out.println(col2.contains(&quot;wanfeng&quot;));\t\tSystem.out.println(col2.contains(s1));\t\tSystem.out.println(col2.contains(new Student(&quot;wanfeng&quot;, 12)));\t\t// containsAll()\t集合中的元素是否全部存在\t\tCollection col3 = new ArrayList();\t\tcol3.add(&quot;wanwan&quot;);\t\tcol3.add(false);\t\tSystem.out.println(col2.containsAll(col3));\t\t// remove(Object o)\t删除指定元素 若为自定义类也需要重写equals方法\t\tSystem.out.println(col2.remove(&quot;fengfeng&quot;));\t\tSystem.out.println(col2.remove(new Student(&quot;wanfeng&quot;, 12)));\t\t// removeAll(Collection c) 删除c中包含的所有元素\t\tSystem.out.println(col2.removeAll(col3));\t\tSystem.out.println(col2);\t\t//retainAll(Collection c) 取交集\t\tCollection col4 = new ArrayList();\t\tcol4.add(34.56);\t\tcol4.add(true);\t\tcol2.retainAll(col4);\t\tSystem.out.println(col2);\t\t// equals(Object o)\t比较两个集合是否相同\t\tcol2.add(true);\t\tCollection col5 = new ArrayList();\t\tcol5.add(true);\t\tcol5.add(34.56);\t\tSystem.out.println(col2.equals(col5));\t\t// hashCode()\t返回哈希值\t\tSystem.out.println(col2.hashCode());\t\t// toArray()\t转换为数组\t\tObject[] arr = col2.toArray();\t\tfor(int i=0; i&lt;arr.length; i++)&#123;\t\t\tif(i &gt; 0) System.out.print(&quot; &quot;);\t\t\tSystem.out.print(arr[i]);\t\t&#125;\t\tSystem.out.println();\t\t\t\t// Arrays.asList()数组转换为集合\t\tList&lt;Object&gt; list = Arrays.asList(arr);\t\tSystem.out.println(list);\t\t// iterator()\t返回迭代器，用于集合遍历\t&#125;&#125;class Student&#123;\tprivate String name;\tprivate int id;\tpublic Student() &#123;\t&#125;\tpublic Student(String name, int id) &#123;\t\tthis.name = name;\t\tthis.id = id;\t&#125;\t@Override\tpublic boolean equals(Object o) &#123;\t\tSystem.out.println(&quot;Student.equals([o]): 执行成功~&quot;);\t\tif (this == o) return true;\t\tif (o == null || getClass() != o.getClass()) return false;\t\tStudent student = (Student) o;\t\tif (id != student.id) return false;\t\treturn name != null ? name.equals(student.name) : student.name == null;\t&#125;&#125;\n\niterator迭代器Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。Iterator提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。迭代器模式，就是为容器而生。\n/*iterator()\t返回迭代器，用于集合遍历    iterator.next()\t\t迭代器后移，并返回当前指向元素（未开始遍历时指向第一个元素的前面）    iterator.hasNext() \t后面是否存在元素*/Iterator iterator = col2.iterator();while (iterator.hasNext())&#123;    System.out.println(iterator.next());&#125;\n\nforeach遍历Collection col2 = new ArrayList();col2.add(false);col2.add(34.56);col2.add(29);col2.add(&quot;wanwan&quot;);col2.add(&quot;jingyu&quot;);//本质也是用了iterator//item是元素的拷贝，而不是元素本身for(Object item : col2)&#123;    System.out.println(item);&#125;\n\n三、List接口List接口存储有序、可重复的元素。\nList接口实现类相同点：三个类都实现了List接口，存储数据的特点都是有序的、可重复的\n不同点：\n\nArrayList：List的主要实现类。线程不安全，效率高。底层使用Object[]存储\nLinkedList：频繁使用插入、删除操作时效率高，底层使用双向链表存储。\nVector：List的古老实现类（JDK1.0）。线程安全，效率低。底层使用Object[]存储\n\n四、ArrayList源码分析：使用空参构造器ArrayList()时，底层Object[] elementData初始化为{ }，在第一次添加进行扩容调用grow。（JDK8）\npublic class ListTest &#123;\t@Test\tpublic void test1()&#123;\t\tArrayList list = new ArrayList(10);\t\tSystem.out.println(list.size());\t\tlist.add(11);\t\tlist.add(22);\t\tlist.add(33);\t\tlist.add(&quot;wanfeng&quot;);\t\tlist.add(new Student(&quot;jingyu&quot;, 13));\t\tSystem.out.println(list);\t\t// add(int index, Object o)\t将元素添加到索引位置\t\tlist.add(1, &quot;feng&quot;);\t\tSystem.out.println(list);\t\t// addAll(int index, Collection c)\t将集合c中的所有元素添加到索引位置\t\tCollection col2 = new ArrayList();\t\tcol2.add(false);\t\tcol2.add(34.56);\t\tcol2.add(22);\t\tcol2.add(&quot;wanwan&quot;);\t\tcol2.add(&quot;jingyu&quot;);\t\tlist.addAll(2, col2);\t\tSystem.out.println(list);\t\t// size()\t元素个数\t\tSystem.out.println(list.size());\t\t// get(int index)\t获取索引位置的元素\t\tSystem.out.println(list.get(7));\t\t// indexOf(Object o)\t元素首次出现的索引位置，找不到返回-1\t\tSystem.out.println(list.indexOf(22));\t\tSystem.out.println(list.indexOf(999));\t\t// lastIndexOf(Object o)\t元素最后一次出现的索引位置\t\tSystem.out.println(list.lastIndexOf(22));\t\t// remove(int index) / remove(Object o)\t删除元素\t\tObject remove = list.remove(1);\t\tlist.remove(new Integer(22));\t\tSystem.out.println(list);\t\t// set(int index, Object o)\t修改指定位置的元素为o\t\tlist.set(1, new Integer(987));\t\tSystem.out.println(list);\t\t// subList(int start, int end)\t返回指定范围的子集合，左闭右开\t\tList sub = list.subList(2, 8);\t\tSystem.out.println(sub);\t\t// iterator迭代器遍历\t\tIterator iterator = list.iterator();\t\twhile(iterator.hasNext())&#123;\t\t\tSystem.out.println(iterator.next());\t\t&#125;\t\t// foreach 增强for循环\t\tfor(Object item : list)&#123;\t\t\tSystem.out.println(item);\t\t&#125;\t&#125;&#125;\n\n五、LinkedList源码分析：使用空参构造器LinkedList()时，底层声明了Node类型的first和last属性，默认值为null\n常用方法与ArrayList基本一致\n\n\n\n六、Set接口存储无序、不可重复的数据。无序不等于随机，以HashSet为例，数据添加时并非按照索引顺序添加，而是根据数据的hash值顺序添加。不可重复性是指添加的元素按照equals判断时，不能返回true，即只能添加一个。\nSet接口中没有新的方法，都是Collection中的方法\n在实际应用中，Set常用来过滤重复数据\nSet接口实现类\nHashSet：Set主要实现类，线程不安全，可以存储null\nLinkedHashSet：HashSet的子类。遍历时可按照添加顺序遍历\nTreeSet：底层使用红黑树存储。存储的数据必须是同一个类型，可以按照添加对象的指定属性进行排序\n\n七、HashSet底层是一个数组（默认长度为16）。\nHashSet添加元素的机制当添加数据时，取得hash值，根据hash函数放入数组指定的位置。若该位置上已有元素，则比较二者hashCode（若类中没有重写调用Object类中的hashCode，这个方法生成的hasCode是随机的），若不同则添加成功，以链表形式和已有元素连接。若hash值相同则调用equals方法比较，若为false代表不重复，添加成功，否则添加失败。\n\n在Set中添加数据需要注意的规则\n添加的数据所在类一定要重写hashCode()和equals()\n\nequals里用到的属性和hashCode里用到的属性相同\n\n\nIDEA工具中对hashCode()的重写为什么常出现31这个数字？选择系数应尽量选择较大的系数，增加hash地址，减少冲突，提高查找效率。31只占用5bit，相乘造成数据溢出的概率较小。i * 31 &#x3D;&#x3D; (i&lt;&lt;5) - 1，很多虚拟机里都有相关优化。31是一个素数，其他数和31相乘的结果只能被素数本身和这个其他数整除，减少冲突.\n八、LinkedHashSet底层结构与HashSet相同，都是数组，但是添加了双向链表结构，遍历时以链表形式遍历而不是数组，因此可以以添加顺序遍历\n九、TreeSet添加的数据必须是相同类的对象，添加后自动排序，需要实现Comaprable接口，同时实现的ComapreTo方法也用来判断两个元素是否重复\n\n自然排序：实现Comaprable接口，比较两个对象是否重复的标准是compareTo()是否返回0\n定制排序：声明一个Comparator接口的匿名子类的对象（实现compare方法），将该对象作为TreeSet构造器参数时，TreeSet将会以compare方法比较两个对象是否重复\n\npublic class SetTest &#123;    // Tree自然排序\t@Test\tpublic void test3()&#123;\t\tTreeSet set1 = new TreeSet();\t\tset1.add(10);\t\tset1.add(34);\t\tset1.add(6);\t\tset1.add(18);\t\tset1.add(-9);\t\tfor(Iterator iterator= set1.iterator(); iterator.hasNext(); )&#123;\t\t\tSystem.out.println(iterator.next());\t\t&#125;\t\tTreeSet studentSet = new TreeSet();\t\t// Student需要实现Comparable接口\t\tstudentSet.add(new Student(&quot;wanfeng&quot;, 12));\t\tstudentSet.add(new Student(&quot;jingyu&quot;, 20));\t\tstudentSet.add(new Student(&quot;wanwan&quot;, 15));\t\tstudentSet.add(new Student(&quot;jingjing&quot;, 13));\t\tstudentSet.add(new Student(&quot;jingjing&quot;, 34));\t\tfor(Iterator iterator= studentSet.iterator(); iterator.hasNext(); )&#123;\t\t\tSystem.out.println(iterator.next());\t\t&#125;\t&#125;    // TreeSet定制排序\t@Test\tpublic void test4()&#123;\t\tComparator comparator = new Comparator() &#123;\t\t\t@Override\t\t\tpublic int compare(Object o1, Object o2) &#123;\t\t\t\tif(o1 instanceof Student &amp;&amp; o2 instanceof Student)&#123;\t\t\t\t\tStudent s1 = (Student) o1;\t\t\t\t\tStudent s2 = (Student) o2;\t\t\t\t\treturn s1.getId() - s2.getId();\t\t\t\t&#125;else&#123;\t\t\t\t\tthrow new RuntimeException(&quot;类型不一致&quot;);\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;;\t\t// 以comparator比较器作为比较标准\t\tTreeSet studentSet = new TreeSet(comparator);\t\tstudentSet.add(new Student(&quot;wanfeng&quot;, 12));\t\tstudentSet.add(new Student(&quot;jingyu&quot;, 20));\t\tstudentSet.add(new Student(&quot;wanwan&quot;, 15));\t\tstudentSet.add(new Student(&quot;jingjing&quot;, 13));\t\tstudentSet.add(new Student(&quot;jingjing&quot;, 34));\t\tfor(Iterator it=studentSet.iterator(); it.hasNext(); )&#123;\t\t\tSystem.out.println(it.next());\t\t&#125;\t&#125;&#125;\n\n十、Map接口存储键值对（key-value)\nMap接口实现类\nHashMap：Map接口的主要实现类；线程不安全，效率高；可以存储null\nLinkedHashMap：HashMap的子类。在HashMap基础上增加了链表结构，按添加顺序遍历。对于频繁遍历操作，效率优于HashMap\n\n\nTreeMap：添加键值对时进行排序（按key排序的自然排序、定制排序）。底层使用红黑树\nHashtable：Map接口的古老实现类；线程安全，效率低；不能存储null\nProperties：处理配置文件，key-value都是String类型\n\n\n\nMap常用方法（HashMap）@Testpublic void test2()&#123;    Map map1 = new HashMap();    // put(Object key, Object value)\t添加键值对    map1.put(&quot;BB&quot;, 12);    map1.put(&quot;AA&quot;, 23);    map1.put(&quot;CC&quot;, 34);    System.out.println(map1);    // putAll(Map m)\t将m中的键值对全部添加    Map map2 = new HashMap();    map2.put(&quot;wanfeng&quot;, 23);    map2.put(&quot;jingyu&quot;, 21);    map1.putAll(map2);    System.out.println(map1);    // remove(Object key)\t根据key删除键值对,返回value    Object remove_value = map1.remove(&quot;AA&quot;);    System.out.println(&quot;remove_value: &quot;+remove_value);    System.out.println(map1);    // clear()\t删除所有键值对    map2.clear();    System.out.println(&quot;map2 size: &quot;+map2.size());    System.out.println(map2);    // get(Object key)\t获取key对应的value    Object get_value = map1.get(&quot;wanfeng&quot;);    System.out.println(&quot;get_value: &quot;+get_value);    // containsKey(Object key)\t是否包含key    System.out.println(map1.containsKey(&quot;jingyu&quot;));    // containsValue(Object value)\t是否包含value    System.out.println(map1.containsValue(23));    // size()\t获取键值对个数    System.out.println(&quot;map1 size: &quot;+map1.size());    // isEmpty()\tmap是否为空    System.out.println(map1.isEmpty());    System.out.println(map2.isEmpty());    // equals(Map m)\t判断两个map是否相同    System.out.println(map1.equals(map2));&#125;\n\nMap遍历（HashMap）@Testpublic void test3()&#123;    Map map1 = new HashMap();    map1.put(&quot;BB&quot;, 12);    map1.put(&quot;AA&quot;, 23);    map1.put(&quot;CC&quot;, 34);    System.out.println(map1);    // 遍历key：拿到keySet再用iterator遍历    Set keyset = map1.keySet();    for(Iterator it=keyset.iterator(); it.hasNext(); )&#123;        System.out.println(it.next());    &#125;    // 遍历value，拿到Collection，再用iterator或增强for循环遍历    Collection values = map1.values();    for(Object value : values)&#123;        System.out.println(value);    &#125;    // 第一种方式：遍历key-value拿到EntrySet，使用iterator遍历，    // 每一个Entry调用 getKey() 和 getValue() 获取。    // 第二种方式，遍历key的时候调用get(Object key)同时遍历value    Set entrySet = map1.entrySet();    for(Iterator it=entrySet.iterator(); it.hasNext(); )&#123;        Object o = it.next();        Map.Entry entry = (Map.Entry) o;        System.out.println(entry.getKey() + &quot; --&gt; &quot; + entry.getValue());    &#125;&#125;\n\n\n\n十一、HashMapJDK7以前底层结构为数组+链表，JDK8以后增加了红黑树\nMap的结构\nkey：无序、不可重复，用Set存储所有key（key所在类要重写hashCode和equals）\nvalue：无序、可重复，用Collection存储所有key\nkey-value：一个Entry对象，无序、不可重复，用Set存储所有Entry\n\n\nHashMap底层实现原理JDK7\n\n创建HashMap对象后，底层创建了长度为16的数组Entry[] table\nput(key1, value1) 添加键值对时，调用key1所在类的hashCode获取hash值并经过indexFor（和数组长度-1的与运算）得到这个Entry的存放位置，如果此位置没有数据则添加成功。如果此位置已有数据，比较key1的hash值和已有数据的hash值\n若hash值不相同，则添加成功（链表存储）\n若hash值相同，调用equals进行比较\n若返回false，添加成功（链表存储）\n若为true，用value1替换已有数据的value\n\n\n\n\n在不断添加过程中，当超过临界值（threshold）且添加的位置已有元素时，扩容为原来的2倍\n\nJDK8\n\n创建HashMap对象后，底层没有创建长度16的数组\n数组的类型是Node[]，而不是Entry[]\n首次调用put方法时，底层创建长度为16的数组\n当数组某个索引位置（链表）上的元素个数 &gt; 8 且当前数组长度 &gt; 64时，此索引位置上的链表改为红黑树存储\nHashMap中的常量和变量\nDEFAULT_INITIAL_CAPACITY &#x3D; 16：默认容量\nDEFAULT_LOAD_FACTOR &#x3D; 0.75：默认加载因子\nthreshold：扩容临界值 &#x3D; 容量 * 加载因子\nTREEIFY_THRESHOLD &#x3D; 8：Bucket中链表长度大于默认值时，转化为红黑树\nMIN_TREEIFY_CAPACITY &#x3D; 64：链表转化为红黑树时的最小hash表容量\n\n\n\n\n十二、LinkedHashMap在添加数据时与HashMap不同，将键值对添加进数组或链表时，创建了新的Entry对象（重写了HashMap的newNode方法），这个Entry类是带有before和after两个指针指向前后的元素，形成双向链表。\n\n十三、TreeMap向TreeMap中添加key-value，要求key必须都是同一个类的对象，因为要按照key排序（自然排序、定制排序）\nvoid showTreeMap(TreeMap tm)&#123;    if(tm == null)\treturn;    Set keyset = tm.keySet();    for(Iterator it=keyset.iterator(); it.hasNext(); )&#123;        Student key = (Student) it.next();        System.out.println(key + &quot; --&gt; &quot; + tm.get(key));    &#125;&#125;@Testpublic void TreeMapTest()&#123;    //自然排序    TreeMap map1 = new TreeMap();    map1.put(new Student(&quot;wanfeng&quot;, 23), 11);    map1.put(new Student(&quot;jingyu&quot;, 21), 55);    map1.put(new Student(&quot;wanwan&quot;, 25), 44);    map1.put(new Student(&quot;fengfeng&quot;, 18), 22);    showTreeMap(map1);    //定制排序（与TreeSet原理相同，此处用的是Comparator接口的匿名实现类的匿名对象）    TreeMap map2 = new TreeMap(new Comparator() &#123;        @Override        public int compare(Object o1, Object o2) &#123;            if(o1 instanceof Student &amp;&amp; o2 instanceof Student)&#123;                Student s1 = (Student) o1;                Student s2 = (Student) o2;                // name倒序                return -s1.getName().compareTo(s2.getName());            &#125;            throw new RuntimeException(&quot;类型不匹配&quot;);        &#125;    &#125;);    map2.put(new Student(&quot;wanfeng&quot;, 23), 11);    map2.put(new Student(&quot;jingyu&quot;, 21), 55);    map2.put(new Student(&quot;wanwan&quot;, 25), 44);    map2.put(new Student(&quot;fengfeng&quot;, 18), 22);    showTreeMap(map2);&#125;\n\n十四、PropertiesHashtable的子类，处理属性文件。键值对都是String类型\n@Testpublic void propertiesTest()&#123;    FileInputStream fis = null;    FileOutputStream fos = null;    try &#123;        Properties properties = new Properties();        // 得到文件输入流        fis = new FileInputStream(&quot;src/com/lzh/Map/mypro.properties&quot;);        // 将文件输入流加载进Properties对象中        properties.load(fis);        // 获取属性        System.out.println(properties.getProperty(&quot;username&quot;));        System.out.println(properties.getProperty(&quot;password&quot;));        //设置属性        properties.setProperty(&quot;id&quot;, &quot;27&quot;);        fos = new FileOutputStream(&quot;src/com/lzh/Map/mypro.properties&quot;);        properties.store(fos, &quot;comment&quot;);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        try &#123;            if(fis != null)\tfis.close();            if(fos != null) fos.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n十五、Collections工具类@Testpublic void test1()&#123;    ArrayList list = new ArrayList(10);    list.add(&quot;wanfeng&quot;);    list.add(&quot;zhipeng&quot;);    list.add(&quot;jingyu&quot;);    list.add(&quot;xinxin&quot;);    System.out.println(list.size());    System.out.println(list);    //reverse(list)\t反转List    Collections.reverse(list);    System.out.println(&quot;reverse: &quot; + list);    // shuffle(list)\t随机排序List    Collections.shuffle(list);    System.out.println(&quot;shuffle: &quot;+ list);    // sort(list)\t自然排序，升序    Collections.sort(list);    System.out.println(&quot;自然排序：&quot;+list);    // sort(list, Comparator c)\t定制排序    Collections.sort(list, new Comparator&lt;Object&gt;() &#123;        @Override        public int compare(Object o1, Object o2) &#123;            if(o1 instanceof String &amp;&amp; o2 instanceof String)&#123;                String s1 = (String) o1;                String s2 = (String) o2;                return -s1.compareTo(s2);            &#125;            throw new RuntimeException(&quot;类型不匹配&quot;);        &#125;    &#125;);    System.out.println(&quot;定制排序：&quot;+list);    // swap(index1, index2)\t交换两个索引位置的元素    Collections.swap(list, 0, 2);    System.out.println(&quot;swap：&quot;+list);    // max(Collection)\t获取最大值（自然排序）    // max(Collection, Comparator)\t获取最大值（定制排序）    // min(Collection)\t获取最小值（自然排序）    // min(Collection, Comparator)\t获取最小值（定制排序）    //frequency(Collection, Object)\t返回集合中指定元素的出现次数    System.out.println(Collections.frequency(list, &quot;wanfeng&quot;));    // copy(List list1, List list2)\t将list2对应索引位置的元素复制到list1中    // \t\tlist2.size() &gt; list1.size()\t抛出IndexOutOfBoundsException    ArrayList list2 = new ArrayList();    list2.add(&quot;345&quot;);    list2.add(&quot;111&quot;);    Collections.copy(list, list2);    System.out.println(list);    // replaceAll(List list, Object oldVal, Object newVal)\t将list中的所有旧值改为新值    Collections.replaceAll(list, &quot;zhipeng&quot;, &quot;newval&quot;);    System.out.println(list);    // Collection同步控制    // synchronizedCollection(Collection)    // synchronizedList(List)\tArrayList线程不安全    // synchronizedMap(Map)\t\tHashMap线程不安全    List syncList = Collections.synchronizedList(list);\t//返回线程安全的List&#125;\n\n\n\n","categories":["Java语言"]}]